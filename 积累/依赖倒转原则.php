<?php
/*
依赖倒转原则，是面向对象的标识，以里氏代换原则为基础，使的开放-封闭原则的实现成为了可能。针对接口的而不是针对实现编程。
场景：高内聚低耦合的计算机主机，上篇中提到过的例子http://www.lanecn.com/article/main/aid-18。内存坏了可以直接拔掉换一个新的，
不会说华硕的主板就不能插你刚从戴尔的主板上拔下的内存。所以，内存条的设计是针对接口的，是一个统一的标准接口，不是一个主板厂商提供一个接口方式。再所以一下
，内存条的设计不是为了实现而去设计的，如果是为了实现，那么我现在要实现它插在戴尔主板上的内存条，它在华硕主板就不能用了。由此，引出一个原则“依赖倒转原则”。
依赖倒转原则：针对接口编程，而不是针对实现编程。高层模块不能依赖于底层模块，而是两者都共同依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
新手总是面向过程的开发，把常用的函数都写成底层的函数。比如数据库操作函数。客户端直接调用数据库操作函数。那么假如有一天客户要求更改数据库呢？就要修改底层的数
据库操作函数，但是，<a href="http://www.lanecn.com/article/main/aid-18">面向对象的洗礼：设计模式（四）之开放-封闭原则</a>
，对修改是封闭的，不应该用修改的方式，而是用扩展的方式，把相同的操作函数都抽象出来。所以是针对接口，而不是针对实现。另一个原则为针对接口的编程在修改时不需要修改
代码，而是扩展的开放-封闭原则提供了实现的原理保障。
里氏代换原则：子类继承父类，则子类可以完全代替父类的所有功能，而不会被使用者察觉。
对于外部只能调用父类的所有public方法，子类则都可以继承过来。
里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
2、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
3、子类中可以增加自己特有的方法。
4、当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
5、当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

反面案例：收音机！芯片，喇叭什么的一大堆焊接在一起，超高的耦合度！
*/